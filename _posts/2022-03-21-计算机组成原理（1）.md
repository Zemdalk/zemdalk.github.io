---
title: 计算机组成原理（1）
tags: A-课程笔记 计算机组成原理
mathjax: true
mathjax_autoNumber: true
key: 计算机组成原理（1）
sharing: true
typora-root-url: ..
---

> 计算机组成原理，第1章 计算机系统概论，第6章 计算机的运算方法（原文如此，章节序应为按照课本序）
> 
> 唐朔飞《计算机组成原理》（第3版）

<!--more-->

# 第1章 计算机系统概论

## 1.1 计算机系统简介

### 1.1.1 计算机的软硬件概念

- **计算机系统**

<center><img src="/assets/images/计组/1.1.png" alt="1.1" style="zoom: 60%;" /></center>

- **计算机的解题过程**

计算机实现的所有任务都是通过执行一条一条指令实现的。

- **计算机的语言**

高级语言→汇编语言→机器语言

### 1.1.2 计算机系统的层次结构

<center><img src="/assets/images/计组/1.2.png" alt="1.2" style="zoom: 60%;" /></center>

### 1.1.3 计算机体系结构和计算机组成

计算机体系结构：程序员见到的计算机系统的属性。

计算机组成：实现计算机体系结构所体现的属性。

## 1.2 计算机的基本组成

### 1.2.1 冯·诺依曼计算机的特点

1. 计算机由五大部件组成：运算器、控制器、存储器、输入/输出设备。
2. 指令和数据以同等地位存于存储器，可按地址寻访。
3. 指令和数据用二进制表示。
4. 指令由操作码和地址码组成。
5. **存储程序。**
6. 以运算器为中心。

**经典冯·诺依曼计算机硬件框图**：

<center><img src="/assets/images/计组/1.3.png" alt="1.3" style="zoom: 60%;" /></center>

**关于“存储程序”**：

“存储程序”是说，任何要被计算机完成的工作都要首先被编写成程序，将程序和原始数据存入计算机并执行，执行过程是自动的。

“存储程序”使得存储与计算分离。计算由硬件定义好，同一套硬件可以执行多种功能——只需要将不同程序存储到存储器中即可。而且，程序可以像数据一样被操作。

存储程序结构是通用图灵机的一种实现方案。

### 1.2.2 现代计算机硬件框图

CPU=ALU+CU，CU(Control Unit)控制单元，ALU(Arithmetic Logic Unit)算术逻辑单元。

存储器分为主存（如内存）和辅存（如硬盘）。

主机=CPU+主存。

### 1.2.3 计算机的工作步骤

- **上机前的准备**

建立数学模型→确定计算方法→编制解题程序。

- **计算机的组成部件和解题过程**

（1）存储器的基本组成

<center><img src="/assets/images/计组/1.4.png" alt="1.4" style="zoom: 60%;" /></center>

① 存储体：按地址寻访

<u>存储体 → 存储单元 → 存储元件</u>

存储单元：用来存放一串二进制代码的**空间**。

存储字：存储单元中存放的这串**二进制代码**。

存储元件：寄存**一位二进制**的“0”或“1”。

存储字长：存储单元存放的二进制代码**位数**。

② MAR与MDR

MAR：存储器地址寄存器，反映存储单元个数。

MDR：存储器数据寄存器，反映存储字长。

例如，设MAR=4位，MDR=8位，则存储单元个数为$2^4=16$个，存储字长为8。

（2）运算器的基本组成

<center><img src="/assets/images/计组/1.5.png" alt="1.5" style="zoom: 60%;" /></center>

（3）控制器的基本组成

<center><img src="/assets/images/计组/1.6.png" alt="1.6" style="zoom: 60%;" /></center>

PC：存放当前欲执行指令的地址。

IR：存放当前欲执行的指令。

CU：控制单元。

（4）主机完成一条指令的过程

取数：

<center><img src="/assets/images/计组/1.7.png" alt="1.7" style="zoom: 60%;" /></center>

存数：

<center><img src="/assets/images/计组/1.8.png" alt="1.8" style="zoom: 60%;" /></center>

## 1.3 计算机硬件的主要技术指标

### 1.3.1 主要指标

- **机器字长**：CPU一次能处理数据的位数，与CPU中的寄存器位数有关。
- **运算速度**：可由多种指标来表征，如主频、MIPS、CPI、FLOPS等。
- **存储容量**：存放二进制信息的总位数。

主频：CPU的时钟频率。

### 1.3.2 CPI与MIPS

① CPI

Cycles Per Instruction，每条指令所用周期数。

两条公式：

- Clock Cycles = Instruction Count × Cycles Per Instruction(CPI)

- CPU Time = Instruction Count × CPI × Clock Cycle Time = Instrcution Count × CPI / Clock Rate

Average CPI：对不同指令的CPI加权平均所得结果。

② MIPS

Millions of Instructions Per Second，每秒处理的百万级的机器语言指令数。

公式：

$$
\begin{aligned}
    MIPS &= \frac{Instrcution\ Count}{CPU\ Time\times 10^6}\\\\
         &= \frac{Clock\ Rate}{CPI \times 10^6}
\end{aligned}
$$

还有Benchmarks（性能基准评测程序），用来评测计算机的性能。

上述指标中单独任何一个都不能完全用来代表计算机性能的好坏，需综合考虑。

# 第6章 计算机的运算方法

## 6.1 无符号数和有符号数

### 6.1.1 无符号数和有符号数

- **无符号数**：每一位均为数值位，n位无符号数表示范围$[0,2^n-1]$，一般用于地址运算、编号表示等。

- **有符号数**：带符号的数，符号位一般为最高位。

### 6.1.2 有符号数表示法

- **原码表示法**

符号位0为正，1为负。其余位为数值位，取真值的绝对值。

<center><img src="/assets/images/计组/6.1.png" alt="6.2" style="zoom: 60%;" /></center>

<center><img src="/assets/images/计组/6.2.png" alt="6.2" style="zoom: 60%;" /></center>

- **补码表示法**

正数补码与原码相同，负数补码为原码除符号位外，按位取反再加一（本质：加“模”）。

<center><img src="/assets/images/计组/6.3.png" alt="6.3" style="zoom: 60%;" /></center>

<center><img src="/assets/images/计组/6.4.png" alt="6.4" style="zoom: 60%;" /></center>

特别注意，假设机器字长为8位，则-128=1000 0000，-1.0=1.000 0000。

求补码对应的原码：正数原码与补码相同，负数原码为补码除符号位外，按位取反再加一。

正负数补码的转换：一个负数的补码等于对应正数补码的“**各位**取反、末位加一”。

- **反码表示法**

正数反码与原码相同，负数反码为原码除符号位外按位取反。

<center><img src="/assets/images/计组/6.5.png" alt="6.5" style="zoom: 60%;" /></center>

<center><img src="/assets/images/计组/6.6.png" alt="6.6" style="zoom: 60%;" /></center>

- **移码表示法**

符号位与补码相反，数值位与补码相同。

目的：方便比较，移码表示对应数值的大小顺序与二进制移码“朴素”的大小顺序一致。另外，移码主要用来表示浮点数的阶码（指数），便于浮点数加减运算时的对阶操作（判断阶码大小）。

## 6.2 数的定点表示和浮点表示

定点/浮点：小数点是固定的还是浮动的。

### 6.2.1 定点表示

$S_f.S_1S_2\cdots S_n$，其中$S_f$为数符，表示小数的正负，$S_1S_2\cdots S_n$为数值部分。

### 6.2.2 浮点表示

浮点数的一般形式：$N=S\times r^j$，称S为尾数，j为阶码，r为基数。

在计算机中，r取2、4、8、16等。S为纯小数（绝对值小于1的小数），可正可负。j为正数，可正可负。

- **浮点数的表示形式**

<center><img src="/assets/images/计组/6.7.png" alt="6.7" style="zoom: 60%;" /></center>

- **浮点数的表示范围**

设阶码有m位，尾数有n位，均用原码表示，且不考虑规格化。

阶码范围：$-(2^m-1)\sim 2^m-1$；

尾数范围：$-(1-2^{-n})\sim -2^{-n},0,2^{-n}\sim 1-2^{-n}$。

因此浮点数的表示范围为：

|最小负数|最大负数|0|最小正数|最大正数|
|:--:|:--:|:--:|:--:|:--:|
|$-2^{2^m-1}\times (1-2^{-n})$|$-2^{-(2^m-1)}\times 2^{-n}$|$0$|$2^{-(2^m-1)}\times 2^{-n}$|$2^{2^m-1}\times (1-2^{-n})$|

不难发现浮点数有两种可能的溢出：

**上溢**：阶码 > 最大阶码，中断溢出；

**下溢**：阶码 < 最小阶码，按**机器零**继续处理。

<center><img src="/assets/images/计组/6.8.png" alt="6.8" style="zoom: 60%;" /></center>

- **浮点数的规格化**

r=2：尾数最高位为1

r=4：尾数最高2位不全为0

r=8：尾数最高3位不全为0

这样做类似于约定科学计数法中尾数位于1-10之间。注意，规格化后浮点数的表示范围不再是上面给出的范围。且规格化操作是针对原码进行的。

习惯上，浮点数采用“阶移、尾补”（阶码用移码，尾数用补码）的形式来表示。

- **机器零**

① 当浮点数尾数为0时，不论气阶码为何值，按机器零处理；

② 当浮点数阶码等于或小于它所表示的最小数时，不论尾数为何值，按机器零处理。

当采用“阶移、尾补”形式表示浮点数时，一种机器零为$0,0000;0.00\cdots 0$，即全零表示机器零。这样的机器零有利于机器中“判0”电路的实现。

- **IEEE 754**

浮点数不仅只有上面介绍的规格化形式，还有其它的规格化表示。早期的计算机各自定义自己的浮点数格式，互不兼容，导致不同机器间数据传递出现麻烦。

1985年完成IEEE 754标准的制定，现在所有的计算机都统一用IEEE 754来表示浮点数。

[在线IEEE 754计算网页](https://babbage.cs.qc.cuny.edu/IEEE-754.old/Decimal.html)

<center><img src="/assets/images/计组/6.9.png" alt="6.9" style="zoom: 60%;" /></center>

## 6.3 定点运算

### 6.3.1 移位运算

分为两种，算术移位和逻辑移位。

- **逻辑移位**

无符号数的移位，左移和右移均添0。

- **算术移位**

有符号数的移位：

<center><img src="/assets/images/计组/6.10.png" alt="6.10" style="zoom: 60%;" /></center>

在移位时我们考虑的是0还是1“有意义”，对于原码1有意义，因此我们添0。对于负数补码，末尾1有意义，最高位0有意义，因此末尾添0，最高位添1。

因此，若移位过程中“有意义”的数码丢失（被移出），则会导致**出错**或者**精度损失**。特别地，左移丢失有意义数**出错**，右移丢失有意义数**影响精度**。

### 6.3.2 加减法运算

- **运算方式**

补码运算。连同符号位一起相加，符号位产生的进位自然丢掉。

- **溢出判断**

(1) 一位符号位判溢出：最高有效位的进位 ⊕ 符号位的进位 = 1 → 溢出

(2) 两位符号位判溢出：结果的双符号位不同 → 溢出

- **设计ALU**

参见实验课课件。

一个关键：

Overflow与CarryOut标志：

Overflow表示**有符号数**加减法**结果是否超出范围**，非此操作时信号未定义；CarryOut表示**无符号数**加减法**结果是否超出范围**，非此操作时信号未定义。

### 6.3.3 乘法运算

