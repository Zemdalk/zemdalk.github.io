---
title: 理论计算机科学基础（6）——第6章
tags: A-课程笔记 理论计算机科学基础
mathjax: true
mathjax_autoNumber: true
key: 理论计算机科学基础（6）——第6章
sharing: true
typora-root-url: ..
---

> 理论计算机科学基础随堂笔记。第6章：递归定理
> 
> 使用教材：《计算理论导引》（原书第3版）  Michael Sipser 著，机械工业出版社

<!--more-->

# 第6章 递归定理

递归定理的各种等价形式，递归定理的证明，递归定理的应用：证明不可计算性。

证明不可计算性的方法：① **计数方法**：$\aleph_0,\aleph_1,...$，Cantor, Godel等人发展；② **对角化方法**：用于证明$A_{TM}$的不可计算性以及停机问题，有局限性；③ **归约**；④ **递归定理**。

## 6.1 各种等价形式

### ① Kleene第二递归定理

$$
\forall 可计算函数t: \Sigma^ * \times \Sigma^ * \to \Sigma^ * (via\ \ TM\ \ T), \quad\exists TM\ R, \quad \\ s.t.\ \ \forall y\in \Sigma^ * , \quad t(\langle R\rangle , y)=R(y)
$$

> 需要注意，这里的可计算函数t与之前定义稍有不同，它可能在某些输入上未定义，这样它对应的图灵机就对这些输入不停机。

### ② 不动点定理

$$
\forall 可计算函数t: \Sigma ^ * \to \Sigma ^ *,\quad \exists TM\ F,\quad \\ s.t.\ \ F与t(\langle F\rangle )对应的图灵机等价
$$

> 即$F$与$t(\langle F\rangle )$对应的图灵机[^1]接受相同的语言。

[^1]: 在不致混淆的情况下，为方便表述，后文有时会直接用$t(\langle M\rangle)$ 指代 $t(\langle M\rangle)$对应的图灵机

### ③ 图灵机自引用

定义图灵机时，允许它引用自己的编码，即如下形式的描述是合法的：

图灵机M = “…………$\langle M\rangle$…………”

### ④ 图灵机自复制

$$
\exists TM\ \ \ SELF, \forall x\in \Sigma^*, SELF(x)=\langle SELF\rangle
$$

## 6.2 证明

我们按照如下次序证明**递归定理的正确性**及**等价定理的等价性**：

<center><img src="/assets/images/理计/6.1.png" alt="6.1" style="zoom: 60%;" /></center>

### $①\Rightarrow ②$

已知可计算函数$t: \Sigma^ * \to \Sigma^ * $，构造①中的可计算函数t所对应的图灵机T：

<center><img src="/assets/images/理计/6.2.png" alt="6.2" style="zoom: 40%;" /></center>

由定理①，存在图灵机F，满足$T(\langle F\rangle,y)=F(y)$。

由T的构造，$T(\langle F\rangle,y)=t(\langle F\rangle )(y)$。

因此$t(\langle F\rangle )(y)=F(y)$，即$t(\langle F\rangle )=F$，这就是②的结论。

### $②\Rightarrow ③$

任给一个可计算函数$t:\Sigma^ * \to\Sigma^ * $，由②，存在一台图灵机M，满足$M$与$t(\langle M\rangle)$对应的图灵机等价。

因$\langle M\rangle$作为自变量，故描述$t(\langle M\rangle)$对应的图灵机时会用到$\langle M\rangle$，即$t(\langle M\rangle)$对应的图灵机的描述具有如下形式：

$t(\langle M\rangle)$ = "…………$\langle M\rangle$…………"

由$M$与$t(\langle M\rangle)$等价，亦可以将M描述为

$M$ = "…………$\langle M\rangle$…………"

### $③\Rightarrow ④$

定义图灵机SELF：

SELF = “对于输入x，删除x，由定理③得到$\langle SELF\rangle$，打印出$\langle SELF\rangle$并停机。”

### 证明$④$

定义图灵机$P_w$：

$P_w$ = “对于输入x，删除x，打印w并停机。”

定义图灵机Q：

Q = “对于输入w，得到图灵机$P_w$，打印$\langle P_w\rangle$并停机。”

定义图灵机B：

B = “对于输入$\langle M\rangle$，用Q计算出$\langle P_{\langle M\rangle}\rangle$，打印$\langle P_{\langle M\rangle}M\rangle$并停机。”

记图灵机$A=P_{\langle B\rangle}$。

有了如上准备，我们来构造图灵机SELF：

$\langle SELF\rangle=\langle AB\rangle$，即SELF如下图所示：

<center><img src="/assets/images/理计/6.3.png" alt="6.3" style="zoom: 80%;" /></center>

$A=P_{\langle B\rangle}$，故$y=\langle B\rangle$，故输出$B(y)=B(\langle B\rangle )=\langle P_{\langle B\rangle }B\rangle=\langle AB\rangle=\langle SELF\rangle$。

> 一个有意思的问题：上面的过程是可以用图灵机实现的，那就意味着也可以用高级程序语言实现，即写一段程序，让它能打印和自身一模一样的代码。在英文里还有个对这种程序的专门的称呼，叫**Quine**[^2]。
> 
> 分析上面的图灵机代码，核心就是我们的图灵机需要打印$\langle P_{\langle B\rangle}B\rangle$，也就是说，先把B的代码打印到纸带上，再把纸带送给B执行，然后把这个动作（打印 - 执行）的代码打印出来，说得更自然一点，就是先把“打印 - 执行”动作（就是一个整个的框架，即除了“打印”不要真的打印，别的动作框架都打印出来）打印出来，然后在“打印”那个地方把整个代码打印出来。或者用伪代码这样描述（`echo`可以理解成`print`）：
> 
> ``` shell
> echo the next line, then echo the next line in quotation marks
> "echo the next line, then echo the next line in quotation marks"
> ```
> 
> bash实现（有点“作弊”的嫌疑）：
> 
> ``` shell
> echo $BASH_COMMAND
> ```
> 
> python实现：
> 
> ``` python
> s = 's = %r\nprint(s %% s)\n'
> print(s % s)
> ```
> 
> C语言实现：
> ``` c
> #include <stdio.h>
> int main(){
> char*s="#include <stdio.h>%cint main(){%cchar*s=%c%s%c;%cprintf(s,10,10,34,s,34,10);return 0;}";
> printf(s,10,10,34,s,34,10);return 0;}
> ```
> 
> 还有很多实现，这里不一一列举了，可参阅：[Quine Programs](https://cs.lmu.edu/~ray/notes/quineprograms/#:~:text=C,-Old%2Dstyle%20%28K%26R)

[^2]: A **quine** is a computer program which takes no input and produces a copy of its own source code as its only output.(from [Quine(computing) - Wikipedia](https://en.wikipedia.org/wiki/Quine_(computing)))

### $④\Rightarrow ①$

核心在于构造图灵机R。令$R=P_{\langle BT\rangle}BT$，其中T为①中已知的二输入图灵机T，$B$为④的证明过程中所构造的图灵机。与④略有不同，为了使这台图灵机能够接受纸带上的输入w，我们重新设计$P_s$，使得$P_s$先打印输入内容，再打印w，即$P_s(w)=ws$。

这样，$R(y)=(P_{\langle BT\rangle}BT)(y)=(BT)(y\langle BT\rangle)\stackrel{!}{=}T(\langle P_{\langle BT\rangle }BT\rangle,y)=T(\langle R\rangle, y)$

注释1已经说明，我们不刻意区分$M$与$\langle M\rangle$，因此这里的T就是函数t，得证。

## 6.3 应用

**<u>例1</u>** 证明

$$
A_{TM}=\left\{\langle M,x\rangle\mid M接受x\right\}
$$

不可判定。

**证明**：反证。假设存在图灵机H判定$A_{TM}$，构造图灵机D：

D = “对于输入x，

将$\langle D,x\rangle$送入H，若H接受则拒绝，反之则接受。”

那么，如果将$\langle D\rangle$送入D，就会有

$$
\begin{aligned}
    D接受\langle D\rangle &\Leftrightarrow \langle D,\langle D\rangle \rangle \in A_{TM}\\
    &\Leftrightarrow H接受\langle D,\langle D\rangle \rangle\\
    &\Leftrightarrow D拒绝\langle D\rangle
\end{aligned}
$$

矛盾！因此$A_{TM}$不可判定。■

**<u>例2</u>** 证明

$$
MIN_{TM}=\left\{\langle M\rangle\mid \forall M', \left|\langle M'\rangle\right|<\left|\langle M\rangle\right|\right\}
$$