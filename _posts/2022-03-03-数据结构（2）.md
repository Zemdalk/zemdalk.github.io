---
title: 数据结构（2）——关于链表的一点思考
tags: A-课程笔记 数据结构
mathjax: true
mathjax_autoNumber: true
key: 数据结构（2）——关于链表的一点思考
sharing: true
typora-root-url: ..
---

> 老师的ppt上有些地方应该是有问题的。

<!--more-->

# 0. 事件发生的背景

今天晚上敲链表的代码，毕竟自己不太熟，想练一下。按照老师ppt上给的代码严格复刻后，写个简单的主函数放到dev-c里去跑，却发现编译不通过。于是回头仔细分析了一下代码，并且回顾了一下上学期学的指针的相关内容，有了下面的思考。

# 1. tydedef中的指针变量

最开始有这么个typedef：

``` c
typedef struct LNode{
	ElemType data;
	struct LNode *next;
}LNode, *LinkedList;
```

这里定义了两个类型，一个类型是LNode，另一个类型是LinkedList，前者就是结构体LNode，后者则指向了结构体LNode。

之后有这样的语句：

``` c
LinkedList *L;
L = (LinkedList *)malloc(sizeof(LNode));
L->next=NULL;
```

第二行是说创建了一个能放LNode的空间，并且让L（它是LinkedList类型的变量）指向了这块空间的起始地址。

关于第三行，复习一下，`L->next`相当于`(*L).next`，就是取出L<u>指向的</u>结构体的next成员。这里就让L指向的结构体的next成员为NULL，空。

然而报错了。错误信息：

> [Error] request for member 'next' in something not a structure or union

查这个错误信息，说是因为->和.用混了，我寻思这也不对啊，没用混啊。将信将疑地改成了.，还是这个错误信息，看来不是这里的问题。回头去看typedef，我们把一个`struct LNode{...} *`定义成了`LinkedList`类型，那这就是说<u>`LinkedList`类型本身就是一个指针</u>，遂把后面含有LinkedList类型声明的地方的 * 全部去掉，改成了这样的语句：

``` c
LinkedList L;
L = (LinkedList)malloc(sizeof(LNode));
L->next=NULL;
```

果然不报错了。

所以有两种修改方式，一种是在定义LinkedList的时候就不把它定义为指针类型，另一种是把后面含有LinkedList类型声明的地方的 * 全部去掉。我选择后者，其一是因为如果不把LinkedList定义为指针类型，它就和LNode没有任何区别了，其二是因为书上选择了后者，书上就没有后面的*。

从另一方面来思考，第二种处理方式也有点麻烦，何不类比前面顺序线性表SqList的定义，只定义类型LinkedList，定义成非指针类型的结构LNode？如果没记错的话，上学期C语言程序设计课中的链表就是这样定义的。

**总结**：

（1）`L->next`相当于`(*L).next`；

（2）LinkedList已经是指针了，用它来声明变量的时候不要再加 * 符号了。

# 2. 头指针指向的内容

我又尝试着写了一个PrintList()函数，传进一个LinkedList类型的变量L，然后把它对应的链表中的元素都打印出来（元素就设成了int类型）。

我让它从L->data开始打印，然后是L->next->data，依次打印下去，结果发现打印出来的第一个东西是随机数字，后面才是链表中保存的数字。那也就是说刚开始的L->data中没有保存东西。举例来说，我向链表中依次保存1，2，3三个数，那链表中数据的保存形式应该如下：

<center><img src="/assets/images/数据结构/0.1.png" alt="0.1" style="zoom: 80%;" /></center>

**总结**：

L->data中没有东西，L->next指示了第一个元素。即，上图中0处为头结点，1处为首结点。

# 3. 寻找第i-1个元素（有疑问）

在单链表的插入和删除操作中，都涉及到先找到链表中的第i-1个元素，但是它们的判断条件有小不同，插入元素操作是这样处理的：

``` c
while( p && j < i-1){
	p=p->next;
	++j;
}
```

删除元素是这样处理的：

``` c
while(p->next && j < i-1){
	p=p->next;
	++j;
}
if(!(p->next)||j>i-1) return ERROR;
```

看到了两个不同，一个是while循环判断中对p的处理，插入的时候是要求p不为NULL，删除的时候是要求p->next不为NULL，不知道为何有此不同。

另外，删除元素的时候还检查了给的下标是不是超出了链表的范围，但是插入操作没有做这样的检查，不知道为何。