---
title: Verilog自学
tags: A-技术笔记 Verilog
mathjax: true
mathjax_autoNumber: true
key: Verilog自学
sharing: true
typora-root-url: ..
---

> 参考教材：《Verilog数字系统设计教程（第二版）》（夏雨闻 编著）
> Verilog自学真困难。

<!--more-->

# 第一章  设计文件

## 1.1  模块

### 1.1.1  概述

Verilog的基本设计单元是模块。一个模块由两部分构成，一部分描述接口，一部分描述逻辑功能。

**例1** 设计一个2输入(a,b)、2输出(c,d)的模块block，输出c为输入相与，输出d为输入相或。

```Verilog
module block(a,b,c,d)
input a,b;
output c,d;

assign c = a | b;
assign d = a & b;
endmodule
```
### 1.1.2  模块端口的声明

模块的端口声明了模块的输入输出口，格式如下：

```Verilog
module 模块名(口1,口2,口3,口4,...);
```

### 1.1.3  模块内容

模块的内容包括I/O说明、内部信号声明和功能定义。

- **I/O说明**

输入口：

```Verilog
input [信号位宽-1:0] 端口名1;
input [信号位宽-1:0] 端口名2;
...
```

输出口：

```Verilog
output [信号位宽-1:0] 端口名1;
output [信号位宽-1:0] 端口名2;
...
```

I/O说明也可以放在端口声明的语句里，格式如下：

```Verilog
module module_name(input port1,input port2,...
            output port1,output port2,...);
```

- **内部信号声明**

内部信号用reg或wire表示。每个逻辑门输入输出都需要指定wire或reg类型。wire表示直通，即只要输入有变化，输出马上无条件地反映；reg表示一定要有触发，输出才会反映输入。在模块内用到的和端口有关的wire和reg类型变量格式如下：

```Verilog
reg [width-1:0] R变量1,R变量2,...;
wire [width-1:0] W变量1,W变量2,...;
```

- **功能定义**

模块中最重要的是逻辑功能定义部分。有3种方法：

1、用assign声明语句

```Verilog
assign a=b&c;//a为b与c
```

2、用实例元件

```Verilog
and #2 ul(q,a,b);
```

说明：上面语句表示设计中用到一个跟与门(and)一样的，名为u1的与门，输入为a,b，输出为q，#2表示输出延迟为2个单位时间。要求每个实例元件的名字是唯一的。

3、用always语法块

```Verilog
always @ (posedge clk or posedge clr);
begin
    if(clr) q<=0;
    else if(en) q<=d;
end
```

说明：always块既可以描述组合逻辑，又可以描述时序逻辑。上面的例子生成了一个带有异步清除端的D触发器（目前我还看不懂）。

### 1.1.4  模块的引用

类似于程序设计语言里面函数的调用。比如，引用4个可扩展4位比较器来构建16位比较器。

引用方式有两种：

1、严格按照模块定义的端口顺序连接，不必标明原模块的端口名。即

```Verilog
模块名(连接端口1信号名,连接端口2信号名,连接端口3信号名,...);
```

2、用“.”注明原模块是定义时规定的端口名。即

```Verilog
模块名(.端口1名(连接信号1名),.端口2名(连接信号2名),.端口3名(连接信号3名),...);
```

## 1.2  数据类型、常量和变量

### 1.2.1  常量

- **数字**

1、**整数**：

有3种表达：

(1) **<位宽><进制><数字>**

这是最全面的描述方式。如：

```Verilog
8'b10101100  //8：位宽  'b：二进制   即，8位二进制数10101100
8'ha2        //'h：十六进制   即，8位十六进制数a2（位宽是对二进制而言的）
```

(2) **<进制><数字>**

采用默认位宽，由机器决定，至少32位。

(3) **<数字>**

采用默认进制十进制。

2、**x值和z值**：

x代表不定值，z代表高阻态。x可以用来代表十六进制中的4位二进制数的状态，也可以代表八进制中的3位二进制数的状态，二进制数中的1位。z类似。z也可写作"?"。（有啥用？）

```Verilog
4'b10x0
4'b101z
```

3、**负数**：

负号必须写在数字表达式的最前面。

```Verilog
-8'd5   //表示5的补码，用8位二进制表示
```

4、**下划线**：

用来分隔开数的表达，提高程序的可读性。

```Verilog
16'b1010_1011_1100_0011
```

- **parameter型（参数型）**

```Verilog
parameter 参数名1=表达式,参数名2=表达式,参数名3=表达式,...;
```

参数型常用来定义延迟时间和变量宽度。在模块或实例引用时，可通过参数传递改变在被引用模块中已经定义的参数（目前不懂）。

### 1.2.2  **变量**

wire表示直通，即只要输入有变化，输出马上无条件地反映；reg表示一定要有触发，输出才会反映输入。

- **wire型**

wire型数据常用来表示用以assign关键字指定的组合逻辑信号。格式：

```Verilog
wire [位宽-1:0] 数据名1,数据名2,数据名3,...;
```

- **reg型**

就是寄存器，是数据存储单元的抽象。通常，在设计中要用always模块使用行为描述语句来表达逻辑关系。常用reg来表示always模块内的指定信号，代表触发器。格式：

```Verilog
reg [位宽-1:0] 数据名1,数据名2,数据名3,...;
```

- **memory型**

Verilog通过对reg型变量建立数组来对存储器建模，可以描述ROM等存储器。Verilog中没有多维数组，memory格式如下：

```Verilog
reg [n-1:0] 存储器名[m-1:0];
```

如：

```Verilog
reg [7:0] mema[255:0];//存储器名为mema，有256个8位存储单元（寄存器），地址范围是0-255
```

## 1.3  运算符与表达式

### 1.3.1  与大部分程序设计语言含义相同的运算符

- **算术运算符**：+，-，*，/，%

- **位运算符**：\~，&，|，\^(异或)，\^\~(同或)

- **逻辑运算符**：&&，||，!(逻辑非)

- **关系运算符**：<，>，<=，>=

- **移位运算符**：\>\>，<<

### 1.3.2  等式运算符

==，!=：逻辑等式运算符，结果由两个操作数的值决定，由于操作数中某些位可能是不定值x和高阻态z，因此结果可能为不定值x。只要其中一个操作数中含有x或z，结果即为x。

=\==，!\==：case等式运算符（因为它们常用于case表达式的判别），对不定值x和高阻态z也进行比较，两个操作数必须完全一致才为1，否则为0。

### 1.3.3  拼接运算符

{}

使用方法：

```Verilog
{信号1的某几位,信号2的某几位,信号3的某几位,...}
```

如`{a,b[3:0],w,3'b101}`。

重复信号，如：

```Verilog
{4{w}}          //相当于{w,w,w,w}
```

嵌套表达，如：

```Verilog
{b,{3{a,b}}}    //相当于{b,a,b,a,b,a,b}
```

### 1.3.4  缩减运算符

功能：多个与、或、非运算的缩减。如：

```Verilog
reg [3:0] B;
reg C;
    C=&B;
```

相当于

```Verilog
C=((B[0] & B[1]) & B[2]) & B[3];
```

### 1.3.5  赋值语句

<=：非阻塞式赋值，并行执行。一般用于时序电路。

=：阻塞式赋值，后边的语句必须在这句执行完毕才能执行（顺序执行）。一般用于assign语句。

举例说明：

**例2**（非阻塞式赋值）

```Verilog
always @ (posedge clk)
    begin
        b <= a;
        c <= b;
    end
```

事实上实现了下面的电路图：

![例2](\assets\images\Verilog自学\例2.png)

**例3**（阻塞式赋值）

```Verilog
always @ (posedge clk)
    begin
        b = a;
        c = b;
    end
```

事实上实现了下面的电路图：

![例3](\assets\images\Verilog自学\例3.png)

### 1.3.6  块语句

- **顺序块**

特点：块内语句顺序执行；每条语句的延迟时间是相对于前一条语句的仿真时间而言的；直到最后一条语句执行完，程序流程控制才跳出该语句块。

格式：

```Verilog
begin
    语句1;
    语句2;
    ...
    语句n;
end
```

可以自行添加两语句间的时间延迟（此处每条语句的延迟时间是相对于前一条语句的仿真时间而言的）：

```Verilog
begin
    areg=breg;
    #10 creg=areg;
    //在两条赋值语句之间延迟10个时间单位
```

- **并行块**

特点：块内语句同时执行；块内每条语句的延迟时间是相对于程序流程控制进入到块内的仿真时间的。

格式：

```Verilog
fork
    语句1;
    语句2;
    ...
    语句n;
join
```

## 