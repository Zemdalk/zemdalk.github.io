---
title: 计算机组成原理（2）——指令系统
tags: A-课程笔记 计算机组成原理
mathjax: true
mathjax_autoNumber: true
key: 计算机组成原理（2）——指令系统
sharing: true
typora-root-url: ..
---


> 计算机组成原理，第7章：指令系统。
> 
> 唐朔飞《计算机组成原理》（第3版）

<!--more-->

# 第7章 指令系统

## 7.1 机器指令

### 7.1.1 指令的一般格式

指令：操作码+操作数（或其地址码）

#### (1) 操作码

操作码：反映机器做什么操作，有的指令集操作码长度固定，有的指令集操作码长度可变。

扩展操作码技术：是一种变长编码，就是让操作码的位数随地址数的减少而增加，从而充分利用固定的指令字长。扩展方法如下图所示：

<center><img src="/assets/images/计组/7.1.png" alt="7.1" style="zoom: 80%;" /></center>

也可以[15:12]位为1111和1110时都指示非4位操作码，这样三地址操作码减少了一种，但同时二地址操作码就多了$2^4=16$种。（不是15种，因为前缀为1110 1111的也是二地址操作码）

值得注意的是，操作码越短，译码就越快，因此设计指令集时，常用指令可以考虑多使用短操作码。

#### (2) 地址码

设四地址指令构成为：OP(8)-A1(6)-A2(6)-A3(6)-A4(6)，括号中表示该位段长度。它的含义为：(A1)OP(A2)→A3，下条指令地址为A4。

那么它一共需要4次访存：取值一次，取两个源操作数A1,A2两次，写回目的操作数地址A3一次。

### 7.1.2 指令字长

指令字长决定于：① 操作码长度；② 操作数地址的长度；③ 操作数地址的个数。

有的指令集指令字长固定（如MIPS 32固定为32位指令），有的指令集指令字长可变。

## 7.2 操作数类型和操作种类

### 7.2.1 操作数类型

|含义|表示类型|
|:--|:--|
|地址|无符号整数|
|数字|定点数、浮点数、十进制数|
|字符|ASCII|
|逻辑数|逻辑运算|

### 7.2.2 数据在存储器中的存放方式

就是小端序和大端序，以及对齐。

LSB：least significant bit，就是自然表示法下最右边的二进制位（最低位）。例如00101101中，LSB就是最右边的1。

MSB：most significant bit，就是自然表示法下最左边的二进制位（最高位）。例如00101101中，MSB就是最左边的0。

几乎所有机器都用**字节编址**。而一个数常常要占用多个字节，如有的机器中int类型的数据占用4个字节，那么这4个字节应当按照何种顺序在存储器中存放呢？或者说，它一共占用了4个地址，那么哪个地址是起始存放地址呢？这就是**小端序**与**大端序**的问题。我们以存放0x00010203和0x04050607为例：

<center><img src="/assets/images/计组/7.2.png" alt="7.2" style="zoom: 80%;" /></center>

> 简单理解，小端序就是不符合自然阅读习惯的存储方式，大端序就是符合自然阅读习惯的存储方式。

**对齐**：存储器地址按字节编址，各种不同长度的数据存放时，有两种处理方式：**按边界对齐**和**不按边界对齐**。

<center><img src="/assets/images/计组/7.3.png" alt="7.4" style="zoom: 60%;" /></center>

不按边界对齐虽然节省了空间，但是增加了访存次数，因为访存时只能从某个字节开始读到这一行的行末，比如上图中的x占了3行，因此需要访存3次。而按字节对齐时x仅需访存2次。

### 7.2.3 操作类型

#### (1) 数据传送

寄存器→寄存器(MOVE)，

寄存器→存储器(MOVE, STORE, PUSH)，

存储器→寄存器(MOVE, LOAD, POP)，

存储器→存储器(MOVE)。

#### (2) 算术逻辑操作

加、减、乘、除、位运算、浮点运算……

#### (3) 移位操作

算术移位、逻辑移位、循环移位。

#### (4) 转移

① 无条件转移 (JMP)

② 条件转移 (JZ, JO, JC, SKP)

③ 调用和返回 (函数的调用和返回)

函数调用和返回时，返回地址可存放于专用寄存器(\$ra/\$31)、栈指针寄存器(\$sp/\$29)或者子程序的入口地址内。

④ 陷阱(Trap)与陷阱指令

一般不提供给用户使用，在出现事故时由CPU自动产生并执行。

#### (5) 输入输出

## 7.3 寻址方式

**寻址目的**：确定本条指令的操作数地址、下一条欲执行指令的指令地址。

因此，**寻址方式**自然地分为两类：**数据寻址**和**操作数寻址**。

### 7.3.1 指令寻址

#### (1) 顺序寻址

(PC) + 1 → PC

#### (2) 跳跃寻址

由转移指令给出，如`JMP 7`表示跳转到7号地址。

### 7.3.2 数据寻址

记号：EA表示有效地址，即操作数的真实存储地址；A表示形式地址，即指令字中的地址。

#### (1) 立即寻址

A = 操作数

#### (2) 直接寻址

EA = A

#### (3) 隐含寻址

操作数地址隐含在操作码中。例如，ADD指令中，其中一个操作数隐含在ACC寄存器中。

#### (4) 间接寻址

EA = (A)

有**一次间址**和**多次间址**。一次间址是说EA = (A)，多次间址是说A1 = (A), A2 = (A1), ..., EA = (An)。多次间址中，可以由取到数据的标志位判断间接寻址是否结束，例如用第一位为1表示未结束，第一位为0表示已结束。

#### (5) 寄存器寻址

EA = Ri，操作数在寄存器Ri中。

好处是不访存，只访问寄存器，执行速度快。

#### (6) 寄存器间接寻址

EA = (Ri)，有效地址在Ri中，**操作数在存储器中**。

便于编制循环程序。

#### (7) 基址寻址

① 采用专用寄存器作为基址寄存器

EA = (BR) + A，BR是基址寄存器（专用），操作数在存储器中。

② 采用通用寄存器作为基址寄存器

EA = (R0) + A，R0是用户指定的寄存器，操作数在存储器中。

无论是用BR还是R0作基址寄存器，在程序的执行过程中**基址寄存器的内容不变，形式地址A可变**。基址寻址有利于多道程序。

#### (8) 变址寻址

EA = (IX) + A，IX是变址寄存器（专用），操作数在存储器中。

在程序的执行过程中**IX寄存器的内容可变，形式地址A不变**。变址寻址便于处理数组问题。

#### (9) 相对寻址

EA = (PC) + A，A是相对于当前指令的位移量（可正可负，因此是补码表示）。相对寻址利于程序浮动（转移地址不固定，随PC值变化而变化）。

#### (10) 堆栈寻址

由专门的堆栈寄存器SP（指示栈顶位置）寻址。

**总结寻址方式**

|名称|寻址方式|操作数位置|说明|应用|
|:--|:--|:--|:--|:--|
|立即寻址|操作数 = A|指令字|不访存；A的位数限制了立即数的取值范围；立即数可正可负，用补码表示||
|直接寻址|EA = A|存储器|一次访存||
|隐含寻址|隐含在操作码中|不定|可缩短指令字长||
|间接寻址|EA = (A)|存储器|2次访存；分一次间址和多次间址；扩大寻址范围|编制程序|
|寄存器寻址|EA = Ri|寄存器|不访存||
|寄存器间接寻址|EA = (Ri)|存储器|访存|编制循环程序|
|基址寻址|EA = (BR) + A|存储器|基址寄存器BR内容不变，形式地址A可变|多道程序|
|变址寻址|EA = (IX) + A|存储器|变址寄存器IS内容可变，形式地址A不变|处理数组问题|
|相对寻址|EA = (PC) + A|存储器|要跳转的地址和本条指令距离固定|利于程序浮动，广泛用于转移指令|
|堆栈寻址|栈指针寄存器SP指定|存储器|弹栈、压栈时SP的修改与主存编址方法有关||